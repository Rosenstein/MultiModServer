// Jolt - Super agility - Based on utdoublesteps by twistedeuphoria

/* CVARS - copy and paste to shconfig.cfg

//Jolt
jolt_level 0                        

*/

// Fixed issue with client_PreThink, that would cause all other plugins loaded after this one
// to skip client_PreThink unless you had this hero - vittu

#include <amxmod>
#include <superheromod>
#include <Vexd_Utilities>

#if defined AMX98
        #include <xtrafun>
        #define FL_ONGROUND (1<<9)
#endif

#define DOF 1  //Forward
#define DOB 2  //Backward
#define DOR 3  //Right
#define DOL 4  //Left
#define TMINUS 0.5  //Time to activate fly

// VARIABLES
new gHeroName[]="Jolt"
new gHasJoltPower[SH_MAXSLOTS+1]
new bool:gCanJump[SH_MAXSLOTS+1]
new bool:gHasJumped[SH_MAXSLOTS+1]	
new bool:gCanForward[SH_MAXSLOTS+1]
new bool:gCanBack[SH_MAXSLOTS+1]
new bool:gCanRight[SH_MAXSLOTS+1]
new bool:gCanLeft[SH_MAXSLOTS+1]
new bool:gCanDo[SH_MAXSLOTS+1]
new lasthit[SH_MAXSLOTS+1]	
//----------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Jolt","1.1","Bum_Boy16")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	register_cvar("jolt_level", "0")

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	shCreateHero(gHeroName, "Super Agility", "Double tab in any driection to fly in that direction", false, "jolt_level" )

	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	// INIT
	register_srvcmd("jolt_init", "jolt_init")
	shRegHeroInit(gHeroName, "jolt_init")
}
//----------------------------------------------------------------------------------------------
public jolt_init()
{
	// First Argument is an id
	new temp[6]
	read_argv(1,temp,5)
	new id=str_to_num(temp)

	// 2nd Argument is 0 or 1 depending on whether the id has mario
	read_argv(2,temp,5)
	new hasPowers=str_to_num(temp)

	gHasJoltPower[id]=(hasPowers!=0)
}
//----------------------------------------------------------------------------------------------
public client_PreThink(id)
{
	if (!gHasJoltPower[id] || !shModActive() || !hasRoundStarted()) return PLUGIN_CONTINUE
	
	new newbutton = Entvars_Get_Int(id,EV_INT_button)
	new oldbutton = Entvars_Get_Int(id,EV_INT_oldbuttons)
	new flags = Entvars_Get_Int(id,EV_INT_flags)

	//Double Jump
	if((newbutton&IN_JUMP) && !(flags&FL_ONGROUND) && !(oldbutton&IN_JUMP)) {
		if(!gHasJumped[id]) {
			gCanJump[id] = true
			gHasJumped[id] = true
		}
	}
	if((newbutton&IN_JUMP) && (flags&FL_ONGROUND)) {
		gHasJumped[id] = false
		return PLUGIN_CONTINUE
	}

	//Flying forward
	if((newbutton&IN_FORWARD) && (flags&FL_ONGROUND) && !(oldbutton&IN_FORWARD)) {
		if(!gCanDo[id]) {
			new pstr[2]
			pstr[0] = id
			set_task(TMINUS,"can_switch",352+id,pstr,1)
			gCanDo[id] = true
			lasthit[id] = DOF
			return PLUGIN_CONTINUE
		}
		if(gCanDo[id]) {
			if(lasthit[id] == DOF) {
				gCanForward[id] = true
				gCanDo[id] = false
				return PLUGIN_CONTINUE
			}
			else {
				gCanDo[id] = false
				new pstr[2]
				pstr[0] = id
				set_task(TMINUS,"can_switch",314,pstr,1)
				gCanDo[id] = true
				lasthit[id] = DOF
				return PLUGIN_CONTINUE
			}
		}
	}
	
	//Flying Back
	if((newbutton&IN_BACK) && (flags&FL_ONGROUND) && !(oldbutton&IN_BACK)) {
		if(!gCanDo[id]) {
			new pstr[2]
			pstr[0] = id
			set_task(TMINUS,"can_switch",352+id,pstr,1)
			gCanDo[id] = true
			lasthit[id] = DOB
			return PLUGIN_CONTINUE
		}
		if(gCanDo[id]) {
			if(lasthit[id] == DOB) {
				gCanBack[id] = true
				gCanDo[id] = false
				return PLUGIN_CONTINUE
			}
			else {
				gCanDo[id] = false
				new pstr[2]
				pstr[0] = id
				set_task(TMINUS,"can_switch",314,pstr,1)
				gCanDo[id] = true
				lasthit[id] = DOB
				return PLUGIN_CONTINUE
			}
		}
	}
	
	//Flying Right
	if((newbutton&IN_MOVERIGHT) && (flags&FL_ONGROUND) && !(oldbutton&IN_MOVERIGHT)) {
		if(!gCanDo[id]) {
			new pstr[2]
			pstr[0] = id
			set_task(TMINUS,"can_switch",352+id,pstr,1)
			gCanDo[id] = true
			lasthit[id] = DOR
			return PLUGIN_CONTINUE
		}
		if(gCanDo[id]) {
			if(lasthit[id] == DOR) {
				gCanRight[id] = true
				gCanDo[id] = false
				return PLUGIN_CONTINUE
			}
			else {
				gCanDo[id] = false
				new pstr[2]
				pstr[0] = id
				set_task(TMINUS,"can_switch",314,pstr,1)
				gCanDo[id] = true
				lasthit[id] = DOR
				return PLUGIN_CONTINUE
			}
		}
	}
	
	//Flying Left
	if((newbutton&IN_MOVELEFT) && (flags&FL_ONGROUND) && !(oldbutton&IN_MOVELEFT)) {
		if(!gCanDo[id]) {
			new pstr[2]
			pstr[0] = id
			set_task(TMINUS,"can_switch",352+id,pstr,1)
			gCanDo[id] = true
			lasthit[id] = DOL
			return PLUGIN_CONTINUE
		}
		if(gCanDo[id]) {
			if(lasthit[id] == DOL) {
				gCanLeft[id] = true
				gCanDo[id] = false
				return PLUGIN_CONTINUE
			}
			else {
				gCanDo[id] = false
				new pstr[2]
				pstr[0] = id
				set_task(TMINUS,"can_switch",314,pstr,1)
				gCanDo[id] = true
				lasthit[id] = DOL
				return PLUGIN_CONTINUE
			}
		}
	}
	return PLUGIN_CONTINUE
}
//----------------------------------------------------------------------------------------------	
public can_switch(pstr[])
{
	new id = pstr[0]
	
	gCanDo[id] = false
}
//----------------------------------------------------------------------------------------------	
public client_PostThink(id)
{
	//Double Jump
	if(gCanJump[id] == true) {
		new Float:velocity[3]	
		Entvars_Get_Vector(id,EV_VEC_velocity,velocity) //Get their current velocity (to carry other movement/inertia into the jump)
		velocity[2] = random_float(265.0,285.0) //Set height velocity.  Values recieved from testing.
		Entvars_Set_Vector(id,EV_VEC_velocity,velocity) //Set the player's new vector.
		gCanDo[id] = false
		gCanJump[id] = false
		return PLUGIN_CONTINUE
	}
	
	//Flying Forward
	if(gCanForward[id]) {
		new corigin[3]
		new eorigin[3]
		get_user_origin(id,corigin,0)  //Grab their origin
		get_user_origin(id,eorigin,3)  //Grab the origin of the point they are looking at
		new Float:deltax = float(corigin[0]) -  float(eorigin[0])	//Find the difference between the player origin x and aiming origin x
		new Float:deltay = float(corigin[1]) - float(eorigin[1])	//Same for y
		eorigin[0] -= corigin[0]  //Subtract so that the player's origin is (0,0).  Not actually done, I only changed the values I really needed to change.	
		eorigin[1] -= corigin[1]  //Same
		new Float:polardeg = floatatan2(float(eorigin[1]),float(eorigin[0]),1)	//Find the angle between the aiming origin and the x-axis(left-right line on the player)
		if(polardeg < 0.0)  polardeg += 360.0  //Make sure that we are getting the proper angle
		new Float:totalvelo = floatadd(deltax,deltay)  //Find the total movement of x and y
		new Float:xperc = floatdiv(deltax,totalvelo)  //Divide to find the x's share of the movement
		new Float:yperc = floatdiv(deltay,totalvelo)  //Same for the y
		new Float:finalx
		new Float:finaly
		if((polardeg > 135.0) && (polardeg < 314)) { 
			finalx = floatmul(float(-900),xperc)  //Assign their final velocity (900 is arbitrary but works well)
			finaly = floatmul(float(-900),yperc)
		}
		else {
			finalx = floatmul(float(900),xperc)
			finaly = floatmul(float(900),yperc)
		}
		new Float:velocity[3]
		Entvars_Get_Vector(id,EV_VEC_velocity,velocity)
		velocity[0] = finalx	
		velocity[1] = finaly	
		velocity[2] = random_float(200.0,240.0)	
		Entvars_Set_Vector(id,EV_VEC_velocity,velocity)	
		gCanForward[id] = false	
		return PLUGIN_CONTINUE
	}
	
	//Flying Back
	if(gCanBack[id]) {
		new corigin[3]
		new eorigin[3]
		get_user_origin(id,corigin,0)
		get_user_origin(id,eorigin,3)
		new Float:deltax = float(corigin[0]) -  float(eorigin[0])
		new Float:deltay = float(corigin[1]) - float(eorigin[1])
		eorigin[0] -= corigin[0]
		eorigin[1] -= corigin[1]
		new Float:polardeg = floatatan2(float(eorigin[1]),float(eorigin[0]),1)
		if(polardeg < 0.0)  polardeg += 360.0
		new Float:totalvelo = floatadd(deltax,deltay)
		new Float:xperc = floatdiv(deltax,totalvelo)
		new Float:yperc = floatdiv(deltay,totalvelo)
		new Float:finalx
		new Float:finaly
		if((polardeg > 135.0) && (polardeg < 315)) { 
			finalx = floatmul(float(900),xperc)
			finaly = floatmul(float(900),yperc)
		}
		else {
			finalx = floatmul(float(-900),xperc)
			finaly = floatmul(float(-900),yperc)
		}
		new Float:velocity[3]
		Entvars_Get_Vector(id,EV_VEC_velocity,velocity)
		velocity[0] = finalx
		velocity[1] = finaly
		velocity[2] = random_float(200.0,240.0)
		Entvars_Set_Vector(id,EV_VEC_velocity,velocity)
		gCanBack[id] = false
		return PLUGIN_CONTINUE
	}
	
	//Fly Right
	if(gCanRight[id]) {
		new Float:velocity[3]
		Entvars_Get_Vector(id,EV_VEC_velocity,velocity)
		new Float:absx = floatabs(velocity[0])	//Figure out how fast they are moving
		new Float:absy = floatabs(velocity[1])	//Same - this will be used to figure out x/y percentages 
		new Float:total = floatadd(absx,absy)	//Add like in forward and back
		new Float:xperc = floatdiv(absx,total)	//Figure the percentages
		new Float:yperc = floatdiv(absy,total)	//Same
		new Float:finalx
		new Float:finaly 
		if(velocity[0] < 0)  finalx = floatmul(xperc,-900.0)  //Correct the velocities if negative (we used absolute value to calculate above)
		else finalx = floatmul(xperc,900.0)
		if(velocity[1] < 0)  finaly = floatmul(yperc,-900.0)
		else finaly = floatmul(yperc,900.0)
		velocity[0] = finalx
		velocity[1] = finaly
		velocity[2] = random_float(200.0,240.0)	//Give them a little jump
		Entvars_Set_Vector(id,EV_VEC_velocity,velocity)
		gCanRight[id] = false
	}	
	
	//Fly Left
	if(gCanLeft[id]) {
		new Float:velocity[3]
		Entvars_Get_Vector(id,EV_VEC_velocity,velocity)
		new Float:absx = floatabs(velocity[0])
		new Float:absy = floatabs(velocity[1])
		new Float:total = floatadd(absx,absy)
		new Float:xperc = floatdiv(absx,total)
		new Float:yperc = floatdiv(absy,total)
		new Float:finalx
		new Float:finaly 
		if(velocity[0] < 0)  finalx = floatmul(xperc,-900.0)
		else finalx = floatmul(xperc,900.0)
		if(velocity[1] < 0)  finaly = floatmul(yperc,-900.0)
		else finaly = floatmul(yperc,900.0)
		velocity[0] = finalx
		velocity[1] = finaly
		velocity[2] = random_float(200.0,240.0)
		Entvars_Set_Vector(id,EV_VEC_velocity,velocity)
		gCanLeft[id] = false
	}	
	return PLUGIN_CONTINUE
}
//----------------------------------------------------------------------------------------------	
public client_connect(id)
{
	gHasJoltPower[id] = false
	lasthit[id] = 0
}
//----------------------------------------------------------------------------------------------
public client_disconnect(id)
{
	gHasJoltPower[id] = false
	lasthit[id] = 0
}
//----------------------------------------------------------------------------------------------