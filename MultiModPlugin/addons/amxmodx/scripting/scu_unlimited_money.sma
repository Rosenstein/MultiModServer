/* ============================================================
Original post:
https://forums.alliedmods.net/showpost.php?p=1771559&postcount=232?p=1771559

08-14-2012 , 17:52   Re: Server Cvars Unlocker
Arkshine AMX Mod X Plugin Approver Reply With Quote #232
Here some news.

I will make a separate plugin for the money, because :

- Most of memory patches involves money.
- Most of user are more interested with the unlimited money stuff.

A lot of memory patches make the plugin has more chance to be broken because on 
an update, and I would understand he would kind of annoying for the admin to see 
the plugin not working anymore when they don't use it for the money.


That's said, I've just fastly rewritten the code for the money, so it uses less memory 
patches, and should be more reliable.
I've also added a cvar to control the max money : scu_max_money. By default, it's 
set to the max possible value (2147483583).

Here a first version ( ZIP contains orpheu signatures files + source + compiled plugin ) :

- Unzip and overwrite the content of the ZIP in your amxmodx/ directory ;
- Declare the plugin & restart.

*Note: plugin has been tested fastly on CS/CZ windows/linux on the latest version. 
Prepare to die if you say it doesn't !

*Note: not tried on the "hlbeta", but there is no point to use it, so update your server 
if it doesn't work.

*Note: if you see no error, it means the plugin is working. 

*Note: if you have errors, please put the plugin in debug mode, and copy-paste the 
texts generated by the plugin in the amxx logs. You should see something like that 
(here, all is working, just an example) :

L 08/14/2012 - 23:40:23: [Untitled.amxx] SCU: Unlimited Money -- Applying memory patches...
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]        AddAccount::CBasePlayer
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 1/2 (1/20) - patched at 0xa49a1a6. // Check max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 2/2 (2/20) - patched at 0xa49a1b2. // Set max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]        JoiningThink::CBasePlayer
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 1/2 (3/20) - patched at 0xa49a90f. // Check max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 2/2 (4/20) - patched at 0xa49a91b. // Set max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]        Reset::CBasePlayer
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 1/2 (5/20) - patched at 0xa49f5e9. // Check max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 2/2 (6/20) - patched at 0xa49f5f5. // Set max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]        PlayerThink::CHalfLifeTraining
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 1/2 (7/20) - patched at 0xa4b6274. // Check max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 2/2 (8/20) - patched at 0xa4b6359. // Set max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]        CheckStartMoney::
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 1/4 (9/20) - patched at 0xa459a0c. // Check max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 2/4 (10/20) - patched at 0xa459a13. // Set max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 3/4 (11/20) - patched at 0xa459a27. // Check min value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 4/4 (12/20) - patched at 0xa459a2e. // Set min value
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]        ClientPutInServer::
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 1/4 (13/20) - patched at 0xa459b50. // Check max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 2/4 (14/20) - patched at 0xa459b57. // Set max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 3/4 (15/20) - patched at 0xa459b5e. // Check min value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 4/4 (16/20) - patched at 0xa459b65. // Set min value
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]        HandleMenu_ChooseTeam::
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 1/4 (17/20) - patched at 0xa45bf78. // Check max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 2/4 (18/20) - patched at 0xa45bf7f. // Set max value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 3/4 (19/20) - patched at 0xa45bf86. // Check min value
L 08/14/2012 - 23:40:23: [Untitled.amxx]                [OK] - 4/4 (20/20) - patched at 0xa45bf8d. // Set min value
L 08/14/2012 - 23:40:23: [Untitled.amxx]
L 08/14/2012 - 23:40:23: [Untitled.amxx] All the 20 patches have been applied successfully !
*/

#include <amxmodx>
#include <orpheu>
#include <orpheu>
#include <orpheu_memory>
#include <orpheu_advanced>

const MinMoneyOriginalvalue = 800;
const MaxMoneyOriginalValue = 16000;

const MaxMemoryPatches = 20;

enum Patch
{
    PATCH_ADDRESS,
    PATCH_ORIGVALUE,
    PATCH_IS_FLOAT
};

new PatchedAddresses[ MaxMemoryPatches ][ Patch ];
new PatchesCount;

new LocalCount;
new LocalMaxPatches;

new MinNewMoneyValue;
new MaxNewMoneyValue;

new Debug;

public plugin_init()
{
    register_plugin( "SCU: Unlimited Money", "1.0", "Arkshine" );

    Debug = !!( plugin_flags() & AMX_FLAG_DEBUG );

    MaxNewMoneyValue = clamp( get_pcvar_num( register_cvar( "scu_max_money", string( cellmax - 64 ) ) ), 0, cellmax - 64 );
    MinNewMoneyValue = 0;

    if( MaxNewMoneyValue != MaxMoneyOriginalValue )
    {
        handleMemoryPatches();
    }
}

public plugin_end()
{
    removeAllPatches();
}

handleMemoryPatches()
{
    if( Debug )
    {
        log_amx( "" ); log_amx( "SCU: Unlimited Money -- Applying memory patches..." );
    }

    new isLinuxServer = bool:is_linux_server();

    new address;
    new functionSize;
    new extraNumber;
    new displacement;

    address = initFunction( "AddAccount", "CBasePlayer", .numPatches = 2 );
    {
        functionSize = isLinuxServer ? 134 : 120;

        check_and_print( "Check max value", address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue ) );
        check_and_print( "Set max value"  , address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue ) );
    }

    /*address = initFunction( "JoiningThink", "CBasePlayer", .numPatches = 2 );
    {
        functionSize = isLinuxServer ? 986 : 1816;

        check_and_print( "Check max value", address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue ) );
        check_and_print( "Set max value"  , address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue ) );
    }*/

    address = initFunction( "Reset", "CBasePlayer", .numPatches = 2 );
    {
        functionSize = isLinuxServer ? 470 : 339;

        check_and_print( "Check max value", address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue ) );
        check_and_print( "Set max value"  , address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue ) );
    }

    address = initFunction( "PlayerThink", "CHalfLifeTraining", .numPatches = 2 );
    {
        functionSize = isLinuxServer ? 1199 : 1005;
        extraNumber  = isLinuxServer ? 1 : 0;

        check_and_print( "Check max value", address = patchMemory( address, functionSize, MaxMoneyOriginalValue - extraNumber, MaxNewMoneyValue - extraNumber ) );
        check_and_print( "Set max value"  , address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue ) );
    }

    address = initFunction( "CheckStartMoney", "", .numPatches = 4 );
    {
        functionSize = isLinuxServer ? 100 : 65;
        extraNumber  = isLinuxServer ? 1 : 0;
        displacement = isLinuxServer ? 14 : 0;

        check_and_print( "Check max value", address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue - extraNumber ) );
        check_and_print( "Set max value"  , address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue, true, displacement, bool:isLinuxServer ) );
        check_and_print( "Check min value", address = patchMemory( address, functionSize, MinMoneyOriginalvalue - extraNumber, MinNewMoneyValue ) );
        check_and_print( "Set min value"  , address = patchMemory( address, functionSize, MinMoneyOriginalvalue, MinNewMoneyValue, true, displacement, bool:isLinuxServer ) );
    }

    address = initFunction( "ClientPutInServer", "", .numPatches = 4 );
    {
        functionSize = isLinuxServer ? 1434 : 1342;
        extraNumber  = isLinuxServer ? 1 : 0;
        displacement = isLinuxServer ? 8 : 0;

        check_and_print( "Check max value", address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue ) );
        check_and_print( "Set max value"  , address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue, true, displacement, bool:isLinuxServer ) );
        check_and_print( "Check min value", address = patchMemory( address, functionSize, MinMoneyOriginalvalue - extraNumber, MinNewMoneyValue ) );
        check_and_print( "Set min value"  , address = patchMemory( address, functionSize, MinMoneyOriginalvalue, MinNewMoneyValue, true, displacement, bool:isLinuxServer ) );
    }

    /*address = initFunction( "HandleMenu_ChooseTeam", "", .numPatches = 4 );
    {
        functionSize = isLinuxServer ? 3426 : 3009;
        extraNumber  = isLinuxServer ? 1 : 0;
        displacement = isLinuxServer ? 14 : 0;

        check_and_print( "Check max value", address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue ) );
        check_and_print( "Set max value"  , address = patchMemory( address, functionSize, MaxMoneyOriginalValue, MaxNewMoneyValue, true, displacement, bool:isLinuxServer ) );
        check_and_print( "Check min value", address = patchMemory( address, functionSize, MinMoneyOriginalvalue - extraNumber, MinNewMoneyValue ) );
        check_and_print( "Set min value"  , address = patchMemory( address, functionSize, MinMoneyOriginalvalue, MinNewMoneyValue, true, displacement, bool:isLinuxServer ) );
    }*/
}

check_and_print( const comment[], const address )
{
    if( address )
    {
        if( Debug )
        {
            log_amx( "^t^t[OK] - %d/%d (%d/%d) - patched at 0x%x. // %s", LocalCount, LocalMaxPatches, PatchesCount, MaxMemoryPatches, address, comment );

            if( PatchesCount == MaxMemoryPatches )
            {
                log_amx( "" ); log_amx( "All the %d patches have been applied successfully !", MaxMemoryPatches ); log_amx( "" );
            }
        }
    }
    else
    {
        Debug && log_amx( "^t^t[:(] - %d/%d (%d/%d) - failed to find value inside the function // %s", LocalCount, LocalMaxPatches, PatchesCount + 1, MaxMemoryPatches, comment );

        plugin_end();
        set_fail_state( "Memory patch problem - Could not replace a value inside a function." );
    }
}

initFunction( const libFuncName[], const className[], const numPatches )
{
    if( Debug )
    {
        log_amx( "" ); log_amx( "^t%s::%s", libFuncName, className ); log_amx( "" );
    }

    LocalCount = 0;
    LocalMaxPatches = numPatches;

    return OrpheuGetFunctionAddress( OrpheuGetFunction( libFuncName, className ) );
}

patchMemory( const startAddress, const functionSize, const originalValue, const newValue, const bool:isFloat = false, const displacement = 0, const bool:useGOT = false )
{
    new address = startAddress + displacement;
    new endAddress = startAddress + functionSize;

    new type[5]; type = isFloat ? "long" : "int";

    if( useGOT )
    {
        endAddress = address = getBaseAddress() + OrpheuMemoryGetAtAddress( address, "long" ) + getGOTOffset();
    }

    isFloat ? OrpheuMemoryReplaceAtAddress( address, type, 1, float( originalValue ), float( newValue ), address ) :
              OrpheuMemoryReplaceAtAddress( address, type, 1, originalValue, newValue, address );

    LocalCount++;

    if( ( useGOT && address != endAddress ) || address > endAddress )
    {
        isFloat ? OrpheuMemorySetAtAddress( address, type, 1, float( originalValue ) ) :
                  OrpheuMemorySetAtAddress( address, type, 1, originalValue );

        return 0;
    }

    PatchedAddresses[ PatchesCount ][ PATCH_ADDRESS   ] = address;
    PatchedAddresses[ PatchesCount ][ PATCH_ORIGVALUE ] = originalValue;
    PatchedAddresses[ PatchesCount ][ PATCH_IS_FLOAT  ] = isFloat;

    PatchesCount++;

    return useGOT ? startAddress + displacement + 4 :address;
}

removeAllPatches()
{
    new address;
    new value;

    for( new i = 0; i < PatchesCount; i++ )
    {
        address = PatchedAddresses[ i ][ PATCH_ADDRESS ];
        value   = PatchedAddresses[ i ][ PATCH_ORIGVALUE ];

        PatchedAddresses[ i ][ PATCH_IS_FLOAT ] ?

            OrpheuMemorySetAtAddress( address, "long" , 1, float( value ) ) :
            OrpheuMemorySetAtAddress( address, "int", 1, value );
    }
}

getGOTOffset()
{
    static offset; offset || ( offset = OrpheuGetFunctionOffset( OrpheuGetFunction( "_GLOBAL_OFFSET_TABLE_" ) ) );
    return offset;
}

getBaseAddress()
{
    static baseAddress; baseAddress || ( baseAddress = OrpheuGetLibraryAddress( "mod" ) );
    return baseAddress;
}

string( const value )
{
    const bufferSize = 64;

    new string[ bufferSize ];
    formatex( string, charsmax( string ), "%u", value );

    return string;
} 