//Stealth Predator!, Unique Predator that has Invisibility

#include <amxmod>
#include <Vexd_Utilities>
#include <amxmodx> 
#include <fun> 
#include <cstrike>
#include <engine> 
#include <superheromod> 

/*

//Stealth Predator
stealth_level 3
stealth_respawnpct 50			//Percent chance 0-100 of respawning on each death (default=50)
stealth_healpoints 3			//Heal # per second (default=3)
stealth_speed 600			//Running Speed (default=600)

*/

// GLOBAL VARIABLES
new gHeroName[]="Stealth Predator"
new bool:gHasstealthPower[SH_MAXSLOTS+1]
new gUserTeam[SH_MAXSLOTS+1]
new g_powerID[SH_MAXSLOTS+1]
new g_lastWeapon[SH_MAXSLOTS+1]
new bool:g_usingPower[SH_MAXSLOTS+1]
new gPlayerMaxHealth[SH_MAXSLOTS+1]
new bool:g_chargeOver[SH_MAXSLOTS+1]
new bool:gBetweenRounds
new gHealPoints
//-------------------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Stealth Predator", "1.15", "Neogaiden(z)/Strife")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	register_cvar("stealth_level", "3")
	register_cvar("stealth_respawnpct", "50")
	register_cvar("stealth_healpoints", "3")
	register_cvar("stealth_speed", "600" )

	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	shCreateHero(gHeroName, "Speed/Revive/Heal/Invisibility/No Footsteps", "Hold Keydown to go Invisible and No Footsteps ", true, "stealth_level")

	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	// INIT
	register_srvcmd("stealth_init", "stealth_init")
	shRegHeroInit(gHeroName, "stealth_init")

	// Key Down
	register_srvcmd("stealth_kd", "stealth_kd")
	shRegKeyDown(gHeroName, "stealth_kd")

	// Key Up
	register_srvcmd("stealth_ku", "stealth_ku")
	shRegKeyUp(gHeroName, "stealth_ku")

	// Death
	register_event("DeathMsg", "stealth_death", "a")

	//EVENTS
	register_event("CurWeapon", "curweapon", "be", "1=1")

	register_srvcmd("stealth_maxhealth", "stealth_maxhealth")
	shRegMaxHealth(gHeroName, "stealth_maxhealth" )
	gHealPoints = get_cvar_num("stealth_healpoints")

	//HEAL LOOP
	set_task(1.0, "stealth_loop", 0, "", 0, "b")

}
//----------------------------------------------------------------------------------------------
public stealth_init()
{
	// First Argument is an id
	new temp[6]
	read_argv(1, temp, 5)
	new id = str_to_num(temp)

	// 2nd Argument is 0 or 1 depending on whether the id has stealth Powers
	read_argv(2, temp, 5)
	new hasPowers = str_to_num(temp)

	//This gets run if they had the power but don't anymore
	if ( !hasPowers && gHasstealthPower[id] && is_user_connected(id) ){
	// remove the power if it was used and user dropped hero
	if ( g_powerID[id] > 0 ) {
	remove_power(id, g_powerID[id])
	}
	}
	// DO NOT EDIT THIS, MAY CAUSE LUNG CANCER
	gHasstealthPower[id] = (hasPowers != 0)
	shSetMaxSpeed(gHeroName, "stealth_speed", "[0]")
	gPlayerMaxHealth[id] = 100
	g_usingPower[id] = false

#if defined AMX_NEW
}
//----------------------------------------------------------------------------------------------
public client_prethink(id)
{
	if( gHasstealthPower[id] ) {
		Entvars_Set_Int(id, EV_INT_flTimeStepSound, 999)
	}
}

#else

	if ( hasPowers && is_user_connected(id) && g_usingPower[id] ) {
		g_usingPower[id] = true
		set_user_footsteps(id, 1)
	}
	else if ( !hasPowers && gHasstealthPower[id] && is_user_connected(id) ) {
		set_user_footsteps(id, 0)
		g_usingPower[id] = false
	}

}
#endif
//----------------------------------------------------------------------------------------------
public plugin_precache()
{
	precache_sound("shmod/stealthoninvis.wav")
	precache_sound("shmod/stealthrevive.wav")
}
//----------------------------------------------------------------------------------------------
public newSpawn(id)
{
	gBetweenRounds = false
	g_usingPower[id] = false
	set_user_rendering(id)
	set_user_footsteps(id, 0)
}
//----------------------------------------------------------------------------------------------
public stealth_kd()
{
	if ( !hasRoundStarted() )
		return

	// First Argument is an id
	new temp[6]
	read_argv(1, temp, 5)
	new id = str_to_num(temp)

	// Remember this weapon...
	new clip, ammo, weaponID = get_user_weapon(id, clip, ammo)
	g_lastWeapon[id] = weaponID

	// Switch to knife
	engclient_cmd(id, "weapon_knife")

	//R, G, B
	set_user_rendering(id, kRenderFxGlowShell, 55, 55, 55, kRenderTransAlpha)
	gHealPoints = false
	g_usingPower[id] = true
	set_user_footsteps(id, 1)
	shRemSpeedPower(id)
	

	// MODE MESSAGE
	set_hudmessage(0, 0, 200, -1.0, 0.3, 0, 0.25, 1.0, 0.0, 0.0, 4)
	show_hudmessage(id, "Stealth Mode", gHeroName)

	emit_sound(id, CHAN_STATIC, "shmod/stealthoninvis.wav", 1.0, ATTN_NORM, 0, PITCH_NORM)

}
//-------------------------------------------------------------------------------------------------------
public stealth_ku()
{
	if ( gBetweenRounds ) return

	// First Argument is an id
	new temp[6]
	read_argv(1, temp, 5)
	new id = str_to_num(temp)

	if ( !is_user_connected(id) ) return

	// User did not wait long enough.
	if ( !g_chargeOver[id] ) {

		remove_task(id)

		// Stop the sound
		new sndStop=(1<<5)
		emit_sound(id, CHAN_STATIC, "shmod/stealthoninvis.wav", 1.0, ATTN_NORM, sndStop, PITCH_NORM)

		// Switch back to previous weapon...
		if ( g_lastWeapon[id] != CSW_KNIFE ) shSwitchWeaponID(id, g_lastWeapon[id])

		set_user_rendering(id)
		set_user_footsteps(id, 0)
		shRemSpeedPower(id)
		

		// MODE MESSAGE
		set_hudmessage(200, 200, 200, -1.0, 0.3, 0, 0.25, 1.0, 0.0, 0.0, 4)
		show_hudmessage(id, "Normal Mode", gHeroName)
		
		g_usingPower[id] = false
		gHealPoints = get_cvar_num("stealth_healpoints")
		
		return
	}
	
	if ( !is_user_alive(id) || !gHasstealthPower[id] || !g_usingPower[id] ) return
	// Stop the sound
	new sndStop=(1<<5)
	emit_sound(id, CHAN_STATIC, "shmod/stealthoninvis.wav", 1.0, ATTN_NORM, sndStop, PITCH_NORM)
}
//----------------------------------------------------------------------------------------------
public stealth_loop()
{
	if ( !shModActive() ) return
	for ( new id = 1; id <= SH_MAXSLOTS; id++ ) {
		if ( gHasstealthPower[id] && is_user_alive(id) ) {
			// Let the server add the hps back since the # of max hps is controlled by it
			// I.E. Superman has more than 100 hps etc.
			shAddHPs(id, gHealPoints, gPlayerMaxHealth[id])
		}
	}
}
//----------------------------------------------------------------------------------------------
public stealth_mypowers(id)
{
	shRegMaxHealth(gHeroName, "stealth_maxhealth")
	shAddHPs(id, gHealPoints, gPlayerMaxHealth[id])
}
//----------------------------------------------------------------------------------------------
public powerCharged(id)
{
	g_chargeOver[id] = true
}
//----------------------------------------------------------------------------------------------
public stealth_maxhealth()
{
	new id[6]
	new health[9]

	read_argv(1,id,5)
	read_argv(2,health,8)

	gPlayerMaxHealth[str_to_num(id)] = str_to_num(health)
}
//----------------------------------------------------------------------------------------------
public stealth_death()
{
	new id = read_data(2)

	if ( gBetweenRounds ) return
	if ( !is_user_connected(id) || !gHasstealthPower[id] ) return

	new randNum = random_num(0, 100)
	new pctChance = get_cvar_num("stealth_respawnpct")
	if ( pctChance < randNum ) return

	gUserTeam[id] = get_user_team(id)

	// Look for self to raise from dead
	if ( !is_user_alive(id) ) {
		// stealth will raise self from dead
		new parm[1]
		parm[0] = id
		// Respawn him faster then Zues, let this power be used before Zues's
		// never set higher then 1.9 or lower then 0.5
		set_task(0.8, "stealth_respawn", 0, parm, 1)
	}
}
//----------------------------------------------------------------------------------------------
public stealth_respawn(parm[])
{
	new id = parm[0]

	if ( !is_user_connected(id) || is_user_alive(id) ) return
	if ( gBetweenRounds ) return
	if ( gUserTeam[id] != get_user_team(id) ) return //prevents respawning spectators

	emit_sound(id, CHAN_STATIC, "shmod/stealthrevive.wav", 1.0, ATTN_NORM, 0, PITCH_NORM)

	// Double spawn prevents the no HUD glitch
	user_spawn(id)
	user_spawn(id)

	set_task(1.0, "stealth_teamcheck", 0, parm, 1)
}
//-------------------------------------------------------------------------------------------------------
public stealth_teamcheck(parm[])
{
	new id = parm[0]

	if ( gUserTeam[id] != get_user_team(id) ) {
		client_print(id, print_chat, "[SH] You changed teams and can't revive and so you die")

		user_kill(id, 1)

		// Stop stealth from respawning until round ends
		remove_task(177+id)
	}
}
//----------------------------------------------------------------------------------------------
public curweapon(id)
{
	if ( !is_user_alive(id) || gBetweenRounds ) return
	if ( !gHasstealthPower[id] || !g_usingPower[id] ) return

	new wpnid = read_data(2)

	if ( wpnid != CSW_KNIFE ) {
		// Knife only when using power
		engclient_cmd(id, "weapon_knife")
	}
}
//----------------------------------------------------------------------------------------------
public remove_power(id, powerID)
{
	// Reset Variables
	g_powerID[id] = 0
	g_usingPower[id] = false

	// Stop the sounds
	new sndStop=(1<<5)
	emit_sound(id, CHAN_STATIC, "shmod/stealthoffinvis.wav", 1.0, ATTN_NORM, sndStop, PITCH_NORM)

	RemoveEntity(powerID)

	if ( is_user_connected(id) ) {
		// Switch back to previous weapon and reset speed...
		if ( g_lastWeapon[id] != CSW_KNIFE ) shSwitchWeaponID(id, g_lastWeapon[id])
	}
}
//----------------------------------------------------------------------------------------------
public round_end()
{
	if ( !shModActive() ) return

	gBetweenRounds = true

	// Reset the cooldown on round end, to start fresh for a new round
	for ( new id = 1; id <= SH_MAXSLOTS; id++ ) {
		if ( gHasstealthPower[id] ) {
			remove_task(177+id)
		}
	}
}
//-------------------------------------------------------------------------------------------------------
public client_disconnect(id)
{
	// stupid check but lets see
	if ( id <= 0 || id > SH_MAXSLOTS ) return

	// Yeah don't want any left over residuals
	remove_task(id)

	gHasstealthPower[id] = false
}
//-------------------------------------------------------------------------------------------------------
public client_connect(id)
{
	gHasstealthPower[id] = false
}
//-------------------------------------------------------------------------------------------------------