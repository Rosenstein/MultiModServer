//Black Hole! Spawn a black hole that sucks up ur enemies(if u get sucked in u implode causin damage to allies)

/* CVARS - copy and paste to shconfig.cfg

//Black Hole
black_level 10
black_time 15    //amnt of time the black hole stays after spawned
black_cooldown 30  //amnt of time before they can use again
black_range 1000 //how how far can ppl be before it starts pullin em in
black_force 800 //how strong it is
black_adminflag o //go on guess what this does
black_thinktime 2 //how long victims get to pray to their god

*/

#include <amxmod>
#include <Vexd_Utilities>
//#include <VexdUM_stock>
#include <superheromod>

// GLOBAL VARIABLES
new g_heroName[]="Black Hole"
new bool:gHasBHPower[SH_MAXSLOTS+1]
new gBHTimer, gCurrentBH
new ppl[SH_MAXSLOTS], pnum
new gRange, gForce
new g_lastPosition[SH_MAXSLOTS+1][3]
//-------------------------------------------------------------------------------------------------
public plugin_init()
{
	// Plugin Info
	register_plugin("SUPERHERO Black Hole", "1.0", "Random1")

	// DO NOT EDIT THIS FILE TO CHANGE CVARS, USE THE SHCONFIG.CFG
	register_cvar("black_level", "3")
	register_cvar("black_time", "15")
	register_cvar("black_cooldown", "30")
	register_cvar("black_range", "1000")
	register_cvar("black_force", "800")
	register_cvar("black_adminflag", "o")
	register_cvar("black_thinktime", "2")
	
	// FIRE THE EVENT TO CREATE THIS SUPERHERO!
	shCreateHero(g_heroName, "Black Hole(Admin Only!)", "+power key for a black hole to suck up ur enemies", true, "black_level")

	// REGISTER EVENTS THIS HERO WILL RESPOND TO! (AND SERVER COMMANDS)
	// INIT
	register_srvcmd("black_init", "black_init")
	shRegHeroInit(g_heroName, "black_init")
	
	// KEY DOWN
	register_srvcmd("black_kd", "black_kd")
	shRegKeyDown(g_heroName, "black_kd")

	// NEW SPAWN
	register_event("ResetHUD", "newSpawn", "b")
	
	// LOOP
	set_task(1.0, "black_loop", 0, "", 0, "b")
	
}
//-------------------------------------------------------------------------------------------------
public plugin_precache()
{
	precache_model("models/shmod/blackhole.mdl")
}
//-------------------------------------------------------------------------------------------------
public black_init()
{
	// First Argument is an id
	new temp[6]
	read_argv(1,temp,5)
	new id = str_to_num(temp)

	// 2nd Argument is 0 or 1 depending on whether the id has the hero
	read_argv(2,temp,5)
	new hasPowers = str_to_num(temp)

	gHasBHPower[id] = (hasPowers != 0)
	
	if ( hasPowers ) {
		// Make sure looop doesn't fire for them
		gBHTimer = -1
		black_admincheck(id)
	}
	//This gets run if they had the power but don't anymore
	else if ( gHasBHPower[id] && gBHTimer >= 0 ) {
		black_endmode(id)
	}

}
//----------------------------------------------------------------------------------------------
public black_kd()
{
	// First Argument is an id
	new temp[6]
	read_argv(1,temp,5)
	new id = str_to_num(temp)

	if ( !is_user_alive(id) || !gHasBHPower[id] || !hasRoundStarted() || !shModActive() ) return 

	if ( gPlayerUltimateUsed[id] || gBHTimer > 0 ) {
		playSoundDenySelect(id)
		return 
	}
	if( gCurrentBH ) {
		client_print(id,print_chat,"[SH](Black Hole) There is one in use wait till its done")
		playSoundDenySelect(id)
		return 
	}
	
	black_admincheck(id)
	
	gRange = get_cvar_num("black_range")
	gForce = get_cvar_num("black_force")
	gBHTimer = get_cvar_num("black_time")
	if (get_cvar_float("black_cooldown") > 0.0 ) ultimateTimer(id, get_cvar_float("black_cooldown"))
	
	black_create(id)
	positionChangeTimer(id)
	new black_hole = FindEntity(-1, "black_hole")
	gCurrentBH = black_hole
}
//----------------------------------------------------------------------------------------------
public positionChangeTimer(id)
{
	if ( !is_user_alive(id) ) return

	get_user_origin(id, g_lastPosition[id])

	new Float:velocity[3]
	Entvars_Get_Vector(id, EV_VEC_velocity, velocity)

	if ( velocity[0]==0.0 && velocity[1]==0.0 ) {
		// Force a Move (small jump)
		velocity[0] += 20.0
		velocity[2] += 100.0
		Entvars_Set_Vector(id, EV_VEC_velocity, velocity)
	}

	set_task(0.4, "positionChangeCheck", id)
}
//----------------------------------------------------------------------------------------------
public positionChangeCheck(id)
{
	if ( !is_user_alive(id) ) return

	new origin[3]
	get_user_origin(id, origin)
	origin[0]-=60

	if ( g_lastPosition[id][0] == origin[0] && g_lastPosition[id][1] == origin[1] && g_lastPosition[id][2] == origin[2] && is_user_alive(id) ) {
		client_print(id, print_center, "You manged to get stuck in a wall, sry avoid walls next time")
		user_kill(id)				
	}
}
//----------------------------------------------------------------------------------------------
public black_create(id)	
{	
	new Float:vAim[3], Float:vOrigin[3]
	entity_get_vector(id, EV_VEC_origin, vOrigin)
	VelocityByAim(id, random_num(2, 4), vAim)
	
	vOrigin[0] += vAim[0]
	vOrigin[1] += vAim[1]
	vOrigin[2] += 30.0
	
	new black_hole = create_entity("info_target")
	entity_set_string(black_hole, EV_SZ_classname, "black_hole")
	entity_set_model(black_hole, "models/shmod/blackhole.mdl")	
	entity_set_size(black_hole, Float:{-1.5, -1.5, -0.5}, Float:{1.5, 1.5, 0.5})
	entity_set_int(black_hole, EV_INT_solid, 2)
	entity_set_int(black_hole, EV_INT_movetype, 6)
	entity_set_vector(black_hole, EV_VEC_origin, vOrigin)
	
	new origin[3]
	get_user_origin(id, origin)
	origin[0]+=50
	set_user_origin(id, origin)	
}
//-------------------------------------------------------------------------------------------------
public black_loop()
{
	if( !gCurrentBH) return

	if( !shModActive() || gBHTimer < 1) {
		gCurrentBH = 0
		gBHTimer = 0
		new black_hole = FindEntity(-1, "black_hole")
		if (is_valid_ent(black_hole)){
			remove_entity(black_hole)
		}
		return
	}

	gBHTimer--

	new Float:fl_Origin[3]
	entity_get_vector(gCurrentBH, EV_VEC_origin, fl_Origin)
	
	// Do player physics	
	get_players(ppl, pnum, "a")
	for (new i = 0; i < pnum; i++) {
		if(ppl[i] == gCurrentBH) continue

		if(get_entity_distance(ppl[i], gCurrentBH) > gRange ) 	
			continue
			
		new black_hole = FindEntity(-1, "black_hole")
		if( !is_valid_ent(black_hole) ) {
			gCurrentBH = 0
			gBHTimer = 0
		}
				

		SuckPlayerIntoBH(ppl[i], fl_Origin)
	}
	
}
//-------------------------------------------------------------------------------------------------
public newSpawn(id)
{
	gPlayerUltimateUsed[id] = false
	gBHTimer = -1
	gCurrentBH = 0
	black_endmode(id)
}
//-------------------------------------------------------------------------------------------------
SuckPlayerIntoBH(id, Float:fl_Eye[3])
{
	new Float:fl_Player[3], Float:fl_Target[3], Float:fl_Velocity[3], Float:fl_Distance
	entity_get_vector(id, EV_VEC_origin, fl_Player)

	if ( gHasBHPower[id] ) return
	
	fl_Target[0] = fl_Eye[0]
	fl_Target[1] = fl_Eye[1]
	fl_Target[2] = fl_Eye[2]
	//fl_Target[2] = 90.0

	fl_Distance = vector_distance(fl_Player, fl_Target)

	fl_Velocity[0] = (fl_Target[0] -  fl_Player[0]) / fl_Distance
	fl_Velocity[1] = (fl_Target[1] -  fl_Player[1]) / fl_Distance
	fl_Velocity[2] = (fl_Target[2] -  fl_Player[2]) / fl_Distance

	fl_Target[0] += fl_Velocity[1]
	fl_Target[1] -= fl_Velocity[0]
	fl_Target[2] += fl_Velocity[2]

	// Recalculate our direction and set our velocity
	fl_Distance = vector_distance(fl_Player, fl_Target)

	fl_Velocity[0] = (fl_Target[0] -  fl_Player[0]) / fl_Distance
	fl_Velocity[1] = (fl_Target[1] -  fl_Player[1]) / fl_Distance
	fl_Velocity[2] = (fl_Target[2] -  fl_Player[2]) / fl_Distance

	fl_Velocity[0] = fl_Velocity[0] * gForce
	fl_Velocity[1] = fl_Velocity[1] * gForce
	fl_Velocity[2] = fl_Velocity[2] * gForce
	
	entity_set_vector(id, EV_VEC_velocity, fl_Velocity)
}
//-------------------------------------------------------------------------------------------------
public black_endmode(id)
{
	if ( !is_user_connected(id) ) return

	gBHTimer = -1
	gCurrentBH = 0

	
	new black_hole = FindEntity(-1, "black_hole")
	if (is_valid_ent(black_hole)){
		remove_entity(black_hole)
	}
}
//-------------------------------------------------------------------------------------------------
public entity_touch(entity1, entity2) 
	{
		if(!is_valid_ent(entity2) || !is_valid_ent(entity1))
			return PLUGIN_CONTINUE
			
		if(!is_user_connected(entity2) || !is_user_alive(entity2))
			return PLUGIN_CONTINUE
			
		if( gHasBHPower[entity2] )
			return PLUGIN_CONTINUE	
			
	
		new classname[32]
		entity_get_string(entity1, EV_SZ_classname, classname, 31)
		if(equal(classname, "black_hole")) 
		{
			Teleport(entity2)
		}
		return PLUGIN_CONTINUE
}
//---------------------------------------------------------------------------------------------- 
public Teleport(entity2)
{
		new origin[3]
		get_user_origin(entity2, origin)
		origin[2]-=3000
		set_user_origin(entity2, origin)
		client_print(entity2, print_center, "You have been Sucked up into the black hole")
		
		new parm[1]
		parm[0]=entity2
		set_task(get_cvar_float("black_thinktime"), "remove_player", entity2, parm, 1)
}
//---------------------------------------------------------------------------------------------------
public remove_player(parm[])
{
	new id = parm[0]
	client_print(id, print_center, "Hope your life flashed before your eyes, its time to die")
	user_kill(id)
}
//---------------------------------------------------------------------------------------------------
public black_admincheck(id)
{
	new accessLevel[10]

	get_cvar_string("black_adminflag", accessLevel, 9)

	if ( gHasBHPower[id] &&  !(get_user_flags(id)&read_flags(accessLevel)) ) {
		client_print(id, print_chat, "[SH](%s) **Admin Only** You are not authorized to use this hero", g_heroName)
		gHasBHPower[id] = false
		client_cmd(id, "say drop %s", g_heroName)
	}
}
//----------------------------------------------------------------------------------------------